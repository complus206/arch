// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <config.h>
#include "Serv.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/protocol/TCompactProtocol.h>
#include <thrift/protocol/TJSONProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "stdio.h"
#include "stdlib.h"
#include "time.h"

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;
using boost::shared_ptr;

void StartNonblockingServer(int port, int protol, int serverType, int threadCount);

class ServHandler : virtual public ServIf {
public:
    ServHandler() {
        // Your initialization goes here
        invokeTimes = 0;
    }
    
    bool create(const Reserve& s) {
        // Your implementation goes here
        if(this->invokeTimes == 0)
        {
            this->start = clock();
        }
        this->invokeTimes++;
        
        if(this->invokeTimes % INVOKE_TIMES == 0)
        {
            double duration = (double)(clock() - this->start) / CLOCKS_PER_SEC;
            //reset clock
            this->start = clock();
            printf("received %d times, used %fseconds, data is reser_no=%d;guest_name='%s';mobile=%s;sum_price=%s;\r\n",
                   this->invokeTimes, duration, s.reser_no, s.guest_name.c_str(), s.contacter_mobile.c_str(), s.sum_price.c_str());
        }
    }
    
    bool createBatch(const std::vector<Reserve> & lst) {
		printf("received %d reserve\r\n", (int)lst.size());
		int i = 0;
		for(i = 0; i < 3; i++)
		{
			Reserve r = lst[i];
			printf("data(%d) is reser_no=%d;guest_name='%s';mobile=%s;sum_price=%s;\r\n",
                   i, r.reser_no, r.guest_name.c_str(), r.contacter_mobile.c_str(), r.sum_price.c_str());
		}
  	}
private:
    uint invokeTimes;
    clock_t start;
};

int main(int argc, char **argv) {
    int port = 9090;
    int protol = 0;			//default protol is binary
    int serverType = 0;		//default server is none bolock
    int threadCount = 64;	//default thread count
    if(argc > 1)
    {
        **argv++;
        protol = atoi(string(*argv).c_str());
    }
    
    if(argc > 2)
    {
        **argv++;
        serverType = atoi(string(*argv).c_str());
    }
    
    if(argc > 3)
    {
        **argv++;
        threadCount = atoi(string(*argv).c_str());
    }

	
	StartNonblockingServer(port, protol, serverType, threadCount);
	
    return 0;
}

void StartNonblockingServer(int port, int protol, int serverType, int threadCount)
{
	shared_ptr<ServHandler> handler(new ServHandler());
    shared_ptr<TProcessor> processor(new ServProcessor(handler));
    
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    
    //设置数据格式
    TProtocolFactory* fac;
    if(protol == 0)
    {
    	fac = new TBinaryProtocolFactory();
    }
    else if(protol == 1)
    {
    	fac = new TCompactProtocolFactory();
    }
    else
    {
    	fac = new TJSONProtocolFactory();
    }
    shared_ptr<TProtocolFactory> protocolFactory(fac);
    
    printf("server started...\r\n");
	if(serverType == 0)
	{
		// using thread pool with maximum 15 threads to handle incoming requests
    	shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(threadCount);
    	shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    	threadManager->threadFactory(threadFactory);
    	threadManager->start();
    
    	//TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);
    	TNonblockingServer server(processor, protocolFactory, port, threadManager);
    	server.serve();
	}
	else if(serverType == 1)
	{
		// using thread pool with maximum 15 threads to handle incoming requests
    	shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(threadCount);
    	shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    	threadManager->threadFactory(threadFactory);
    	threadManager->start();
    
    	TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);
    	server.serve();
	}
    else
    {
    	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    	server.serve();
    }
}

